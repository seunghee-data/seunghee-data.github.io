---
title: "[파이썬 깊게 파기] Day 8: 인덱싱, 명찰과 번호의 대결 (loc vs iloc)"
date: 2026-01-10 00:00:00 +0900
categories: [python]
layout: single
author_profile: true
header:
  overlay_image: "/assets/images/python-10days/day1/Mbanner.png"
---

## 1. 오늘의 목표
데이터라는 거대한 체스판에서 정확한 좌표를 획득하는 법을 배웁니다. 가장 많이 헷갈리는 **loc**와 **iloc**의 철학적 차이를 분석하고 실무적 오류를 예방합니다.

---

## 2. 위치 지정의 두 가지 철학

### 1) 이름 기반 인덱싱: `loc`
* **어원:** **Loc**ation (로케이션 / 특정 장소).
* **심층 분석:** 데이터에 부여된 **'고유한 이름표(Label)'**를 보고 찾아갑니다. 인덱스가 문자열일 때 강력하며, 끝 번호를 **포함**하는 독특한 규칙을 가집니다.

### 2) 순서 기반 인덱싱: `iloc`
* **어원:** **I**nteger (정수) + **Loc**ation.
* **심층 분석:** 이름표를 무시하고 오직 **'메모리상의 물리적 순서'**만 따집니다. 컴퓨터 공학의 표준 슬라이싱 규칙(끝 번호 **제외**)을 엄격히 따릅니다.

---

## 3. 구조적 분석: 왜 두 개를 나눠놓았는가?
* **안정성 vs 효율성:** 데이터 정렬이 바뀌어도 특정 데이터의 '이름'은 변하지 않습니다. 이때 `loc`를 쓰면 데이터 위치가 바뀌어도 안전하게 값을 가져오지만, 단순히 상위 N개를 뽑고 싶을 때는 `iloc`가 물리적으로 훨씬 효율적입니다.

---

## 4. 실습 코드 (심층 주석)

```python
import pandas as pd

# 샘플 데이터 생성
data = {'Score': [90, 80, 70]}
df = pd.DataFrame(data, index=['A', 'B', 'C'])

# 1. loc: 이름으로 접근 (B 포함!)
print(df.loc['A':'B'])

# 2. iloc: 번호로 접근 (Index 2인 C 제외!)
print(df.iloc[0:2])
```

---

## 🧭 오늘의 핵심 분석 및 요약
1. **loc (Location)** = 사람이 붙인 '명찰' 기반. 데이터의 의미적 위치를 고정할 때 유리
2. **iloc (Integer Loc)** = 컴퓨터의 '순서' 기반. 물리적 추출이 필요할 때 유리
3. **Slicing Gap** = loc는 끝 지점을 포함하고, iloc는 제외한다는 차이가 데이터 개수 오류를 만듦
4. **Robustness** = 정렬이 잦은 데이터 분석에서는 `loc`를 사용하는 것이 코드 안정성 측면에서 우월함
